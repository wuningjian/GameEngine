-游戏内如何判断一个点在空气墙内？（空气墙一般是AABB。 若问是否可达可以用射线判断）
6面体，类似齐次裁剪空间的点是否在平面内的判断

-如何判断一个点在多边形内 ？ 如何判断一个点在三角形内
从点做一条射线，穿过三角形，相交一次内，相交两次在外

-快速求中位数
堆排序？

-链表反转
链表一个节点直接返回；遍历链表节点，当前节点的下一个节点指回当前节点，遍历完后交换头尾

-碰撞检测GJK算法
明可夫斯基差

-二维数组， 左上角到右下角 走过的点和最小多少（ 矩阵动态规划)

-A*算法
* 初始化open_set和close_set；
* 将起点加入open_set中，并设置优先级为0（优先级最高）；
* 如果open_set不为空，则从open_set中选取优先级最高的节点n：
    * 如果节点n为终点，则：
        * 从终点开始逐步追踪parent节点，一直达到起点；
        * 返回找到的结果路径，算法结束；
    * 如果节点n不是终点，则：
        * 将节点n从open_set中删除，并加入close_set中；
        * 遍历节点n所有的邻近节点：
            * 如果邻近节点m在close_set中，则：
                * 跳过，选取下一个邻近节点
            * 如果邻近节点m也不在open_set中，则：
                * 设置节点m的parent为节点n
                * 计算节点m的优先级
                * 将节点m加入open_set中
f=g+h  g-距离起点距离（一般是路线权重） h-距离终点的距离 启发式算法（曼哈顿距离，欧几里得距离，对角线距离）
不要h就退化成dijkstra（贪心算法）

-判断点在三角形

-四叉树(2维空间)

-八叉树(3维空间)

-数组内k高频数据 (先统计频率 map/桶； 然后用小顶堆维护其中k大的频率 复杂度nlogk）

-C++ new 和 malloc
new和delete是C++关键字，需要编译器支持；malloc和free是库函数，需要头文件支持。
new做两件事：分配内存和调用类的构造函数，delete是：调用类的析构函数和释放内存。而malloc和free只是分配和释放内存
使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸

-C++  拷贝构造函数参数是什么样的，为什么用const&
拷贝构造函数必须以引用的方式传递参数 有可能导致栈溢出
拷贝构造函数和赋值运算符的行为比较相似，却产生不同的结果；拷贝构造函数使用已有的对象创建一个新的对象，赋值运算符是将一个对象的值复制给另一个已存在的对象。区分是调用拷贝构造函数还是赋值运算符，主要是否有新的对象产生。
关于深拷贝和浅拷贝。当类有指针成员或有动态分配空间，都应实现自定义的拷贝构造函数。提供了拷贝构造函数，最后也实现赋值运算符。

-C++  static作用
一开始就开辟了内存,内存放在全局

-C++ 虚函数可以是静态函数么，虚函数原理
不能，静态成员没有this指针，虚函数索引this -> vptr -> vtable（保存虚函数的地址） ->virtual function

-非递归遍历二叉树


-二分查找
-1,1,0,越界检测


-有1000个玩家，取战斗力前50的玩家
1 先按战力划分区间，再做一次桶排，到50区间做一次快排
2 直接快排，通过快排的分区点，找到第50个
3 维护堆

-opengl渲染流程 深度测试 zbuffer gbuffer 模板测试

https://zhuanlan.zhihu.com/p/162190576 齐次空间裁剪
-两线段求交
都要先做大范围判断，不然会得到错误的结果
二维向量叉乘：符号可定方向
三维向量叉乘：
线段ab cd，向量ac和ab的叉乘与向量ad和ab的叉乘异号，就是相交，一方0一方不为0，就是有一端在线段上。双方都为0还要判断是否重合

--线段和平面相交求交点
1先判断是否两端点分别在平面两边
2线段两端点在平面的投影，连成的线段和投影线段的交点就是平面上的点

-点在平面内外
点带入平面点法式方程，大于零就是在法线正方向

-视锥体裁剪（齐次空间裁剪）
https://zhuanlan.zhihu.com/p/162190576

-lua table实现原理 
数组 key是整数，且小于数组大小的时候，放到组数
hash表 其他放key val（都是TValue）
luaH_new 创建table，luaH_resize 真正分配空间
table[x] = nil,还需注意它的元表里面的x是不是nil

-lua value
typedef union Value {
  GCObject *gc;    /* collectable objects */
  void *p;         /* light userdata */
  int b;           /* booleans */
  lua_CFunction f; /* light C functions */
  lua_Integer i;   /* integer numbers */
  lua_Number n;    /* float numbers */
} Value;

现在gc的主流方法：一是引用计数(python，assetbundle)，二是垃圾收集（lua就是）

-lua gc https://blog.codingnow.com/2018/10/lua_gc.html
所有gc object都链接在global_state的allgc上	luaC_newobj
三色标记法：使GC过程可以分段执行，可以随时中断
global_state->gcstate保存gc状态，lgc的singlestep方法对不同状态做不同处理
初始化都是白色节点，或者无法被访问到的对象是白
灰色：可访问到，但没有递归扫描完全的对象是灰色
黑色：递归扫描完全的对象是黑，不会被删除，当GC完后被重置为白色     
一趟gc下来（一旦所有灰色对象消失，收集过程也就完成了。），黑色再回到白色节点     
原子步骤是 GC 算法正确性的前提
步进式 GC 能够减少每次 GC 工作时的停顿时间，但是无法减少 GC 带来的额外开销                                   

-lua 字符串池实现原理
https://blog.csdn.net/liutianshx2012/article/details/77367508?utm_source=blogxgwz8&utm_medium=distribute.pc_relevant.none-task-blog-title-3&spm=1001.2101.3001.4242
短字符 哈希+链表法 比较字符相等，只需要比较字符指向地址
长字符 走正常gc 相等比价：先比较长度，再逐个字符比较

-lua 
数据栈（数组实现，StkID stack栈底同时也是对应数组的指针，top，stack_last维护），
调用栈 保存当前调用函数的信息

-纹理
纹素密度，纹理压缩

-lightmap
光照贴图过程将预先计算场景中表面的亮度，并将结果存储在图表或“光照贴图”中供以后使用。
分HDR（exr），LDR
边缘漏光：uv太密，导致双线性过滤的时候出现混叠现象

-UGUI
1、使用UGUI有哪些可以优化的地方？
2、Unity图片压缩格式的选择？

3、UGUI中如果控件的Z轴坐标为负数，会进行合批操作吗？
4、UGUI中Image控件的透明度为0会合批吗？scale为0时会合批吗？
5、粒子怎么显示在两个UI控件之间？
设置sortingorder

6、UGUI怎么合并drawcall？
使用相同纹理节点的尽量放在一起

7、UGUI中mask控件怎么使用？它的实现原理是什么？
即Mask是利用了GPU的模板缓冲来实现的，材质在渲染时会取出StencilBuffer的值，判断是否为1，如果是才进行渲染

8、UGUI中的元素是怎么重建的？ 
通过重写onpopulateMesh增删顶点，脏标记